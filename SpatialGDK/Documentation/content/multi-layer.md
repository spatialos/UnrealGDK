# Multi-layer development
<%(TOC)%>

In SpatialOS, you can split up [server-worker](https://docs.improbable.io/unreal/alpha/content/glossary#workers) computation into layers, with each layer of server-worker instances handling a specific and unique aspect of your game. By default, the GDK for Unreal uses a single Unreal server-worker layer to handle all server-side computation. However, you can set up additional non-Unreal layers, made up of server-worker instances that do not use Unreal or the GDK. 

You can use non-Unreal layers to modularize your game’s functionality so you can re-use the functionality across different games. For example, you could use a non-Unreal layer written in Python that interacts with a database or other 3rd party service, such as [Firebase](https://firebase.google.com/) or [PlayFab](https://playfab.com/). 
## Layers in SpatialOS
A SpatialOS layer has two elements;

* a group of SpatialOS [entity components](https://docs.improbable.io/unreal/alpha/content/glossary#spatialos-entity),
* server-worker instances of a worker type that have [write access authority](https://docs.improbable.io/unreal/alpha/content/glossary#authority) over the group of components. 

(For information on layers in non-GDK SpatialOS development, see the [SpatialOS documentation] (https://docs.improbable.io/reference/latest/shared/worker-configuration/layers#layers).)

## How to integrate non-Unreal layers into your game
In order to interact with each other, Unreal and non-Unreal server-worker instances need to send and receive updates to and [commands](https://docs.improbable.io/reference/latest/shared/glossary#command) for the same SpatialOS components. We recommend that you define the SpatialOS components used by non-Unreal worker instances manually in [schema](https://docs.improbable.io/unreal/alpha/content/glossary#schema) files, separate from those automatically generated by the GDK.  This is because:

* SpatialOS command data in GDK-generated schema files is encoded as byte strings, making deserialization of commands in non-Unreal server-worker types more difficult. 
* It aids portability; you can more easily re-use any non-Unreal server-worker types when you have an accompanying schema file.

Default single Unreal layer development doesn’t accommodate schema files that haven’t been generated by the SDK, so you need to set your game up to handle this.
### How to set up interaction
To set up your game to interact with SpatialOS components defined outside the GDK (external SpatialOS components), you use the following:

* To send SpatialOS component updates and commands, use methods defined in the `SpatialWorkerConnection.h` file (described in the examples section below). 
* To receive [network operations](https://docs.improbable.io/reference/latest/shared/design/operations) for external SpatialOS components, you must provide custom callbacks for specific component IDs and operation types. The GDK then forwards the operations to your callbacks. (This is described in the examples section below.)


>**TIP:** If you’re using schema from outside the GDK, you can customise [snapshot generation](https://docs.improbable.io/unreal/alpha/content/generating-a-snapshot#when-to-generate-a-snapshot) from the GDK toolbar’s  **Snapshot** button. This is to serialize additional entities with these external components which the default Unreal snapshot generation cannot currently do. See [Add to snapshots](#add-to-snapshots) below for how to do this.

#### Send data
You set up your game to send SpatialOS component updates, command requests, and command responses directly using the `SpatialWorkerConnection.h` public methods:

* `void SendComponentUpdate(Worker_EntityId EntityId, const Worker_ComponentUpdate* ComponentUpdate);`
* `Worker_RequestId SendCommandRequest(Worker_EntityId EntityId, const Worker_CommandRequest* Request, uint32_t CommandId);`
* `void SendCommandResponse(Worker_RequestId RequestId, const Worker_CommandResponse* Response);`

You access these methods via a reference to the net driver, as shown below:

`SpatialWorkerConnection connection = Cast<USpatialNetDriver>(World->GetNetDriver())->Connection;`

There is a basic example in the _Examples_ section below. For more examples of how to construct component updates, command requests, and more, see the SpatialOS documentation on  [serialization in the Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/serialization).

#### Receive data

>**Note:** Your external SpatialOS components must have an ID between 1000 and 2000 to be registered by the pipeline. 

You set up your game to receive component updates through implementing callbacks for specified SpatialOS component IDs and operation types. The GDK detects your callbacks when it’s initialized and uses them for all received data relating to components with IDs in the range 1000 to 2000.
To create callbacks, you need to create a class derived from the GDK `UOpCallbackTemplate` base class and implement `GetComponentId` and one or more of the callback methods. These callback methods are parameterized by the following network operation types:

* `virtual void OnAddComponent(const Worker_AddComponentOp& Op) {}`
* `virtual void OnRemoveComponent(const Worker_RemoveComponentOp& Op) {}`
* `virtual void OnComponentUpdate(const Worker_ComponentUpdateOp& Op) {}`
* `virtual void OnAuthorityChange(const Worker_AuthorityChangeOp& Op) {}`
* `virtual void OnCommandRequest(const Worker_CommandRequestOp& Op) {}`
* `virtual void OnCommandResponse(const Worker_CommandResponseOp& Op) {}`


The `UOpCallbackTemplate` base class contains protected references to the `UWorld` and GDK `StaticComponentView` enabling you to write more meaningful callbacks.

There is a basic example in the _Examples_ section below. For more examples of how to deserialize see the SpatialOS documentation on  [serialization in the Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/serialization).
### Add to snapshots
You can customize snapshot generation by creating a class derived from the GDK `USnapshotGenerationTemplate` base class, and implementing the method below. You have the responsibility of incrementing the `NextEntityId` reference. If you don’t, snapshot generation will fail by attempting to add multiple entities to the snapshot with the same ID.
```  
    * Write to the snapshot generation output stream.
    * @param OutputStream the output stream for the snapshot being created.
    * @param NextEntityId the next available entity ID in the snapshot, this reference should be incremented appropriately.
    * @return bool the success of writing to the snapshot output stream, this is returned to the overall snapshot generation.
    **/
bool WriteToSnapshotOutput(Worker_SnapshotOutputStream* OutputStream, Worker_EntityId& NextEntityId);
```


There is a basic example in the _Examples_ section below. For more examples of how to deserialize see the SpatialOS documentation on  [serialization in the Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/serialization).
### Examples
Below is a simple example schema file which a non-Unreal layer could use to track player statistics:

```
package improbable.session;

type MyRequest {
  string player_name = 1;
}
type MyResponse {}

component Session {
    id = 1337;
    uint32 player_count = 1;
    command MyResponse some_command(My_Request);
}
```

#### Send data
You could serialize and send a component update in your Unreal project code in the following way:

```
void SendSomeUpdate(Worker_EntityId TargetEntityId, Worker_ComponentId ComponentId)
{
    Worker_ComponentUpdate Update = {};
    Update.component_id = ComponentId;
    Update.schema_type = Schema_CreateComponentUpdate(ComponentId);
    Schema_Object* FieldsObject = Schema_GetComponentUpdateFields(Update.schema_type);
    Schema_AddInt32(FieldsObject, 1, ++UnrealCounter);
    Cast<USpatialNetDriver>(World->GetNetDriver())->Connection->SendComponentUpdate(TargetEntityId, &Update);
}
```


You could serialize and send a command response in your Unreal project code in the following way:


```
Worker_RequestId SendSomeCommandRequest(Worker_EntityId TargetEntityId, Worker_ComponentId ComponentId, Schema_FieldId CommandId) {
    Worker_CommandResponse Response = {};
    Response.component_id = ComponentId;
    Response.schema_type = Schema_CreateCommandResponse(ComponentId, CommandId);
    Schema_Object* ResponseObject = Schema_GetCommandResponseObject(Response.schema_type);
    const char* Text = "Hello World.";
    Schema_AddBytes(ResponseObject, 1, (const uint8_t*)Text, sizeof(char) * strlen(Text));
    Cast<USpatialNetDriver>(World->GetNetDriver())->Connection->SendCommandResponse(TargetEntityId, &Response);
}
```


#### Receiving data
You could receive and deserialize a component update and command request in your Unreal project code in the following way:
```
UCLASS()
class SPATIALGDK_API SessionComponentCallbacks : UOpCallbackTemplate
{
    GENERATED_BODY()

public:
    Worker_ComponentId GetComponentId() 
    {
        return 1337;
    }

    void OnComponentUpdate(const Worker_ComponentUpdateOp& Op) override 
    {
        Worker_ComponentUpdate Update = {};
        Update.component_id = 1338;
        Update.schema_type = Schema_CreateComponentUpdate(1338);
        Schema_Object* FieldsObject = Schema_GetComponentUpdateFields(Update.schema_type);
        Schema_AddInt32(FieldsObject, 1, ++UnrealCounter);
        Cast<USpatialNetDriver>(World->GetNetDriver())->Connection-> SendComponentUpdate(39, &Update);
    }

    void OnCommandRequest(const Worker_CommandRequestOp& Op) override
    {
        Worker_CommandResponse Response = {};
        Response.component_id = 1338;
        Response.schema_type = Schema_CreateCommandResponse(1338, 1);
        Schema_Object* ResponseObject = Schema_GetCommandResponseObject(Response.schema_type);

        const char* Text = "My Response text."; 
        Schema_AddBytes(ResponseObject, 1, (const uint8_t*)Text, sizeof(char) * strlen(Text));

        // Spawn an actor using the World pointer
        // (where CubeClass is a Blueprint Actor UClass pointer)
        if (StaticComponentView->HasAuthority(Op.entity_id, GetComponentId())) 
        {
            const FVector Location(0.0f, 0.0f, 0.0f);
            const FRotator Rotation = FRotator::ZeroRotator;
            World->SpawnActor(CubeClass, &Location, &Rotation);
        }

        Cast<USpatialNetDriver>(World->GetNetDriver())->Connection->SendCommandResponse(Op.request_id, &Response);
    }
}
```

### Edit the snapshot
You could add a new entity with the given component in your Unreal project code in the following way:

```
UCLASS()
class SPATIALGDK_API USessionEntitySnapshotGeneration : USnapshotGenerationTemplate
{
    GENERATED_BODY()

public:
    bool WriteToSnapshotOutput(Worker_SnapshotOutputStream* OutputStream, Worker_Entity& NextEntityId) override 
    {
        Worker_Entity SomeEntity;
        SomeEntity.entity_id = NextEntityId;
        TArray<Worker_ComponentData> Components;
        const WorkerAttributeSet ExternalWorkerAttributeSet{ TArray<FString>{TEXT("some_external_worker_type")} };
        const WorkerRequirementSet ExternalWorkerPermission{ ExternalWorkerAttributeSet};
        const WorkerRequirementSet AnyWorkerPermission{ {SpatialConstants::UnrealClientAttributeSet, SpatialConstants::UnrealServerAttributeSet, ExternalWorkerAttributeSet} };
        WriteAclMap ComponentWriteAcl;
        ComponentWriteAcl.Add(SpatialConstants::POSITION_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(SpatialConstants::METADATA_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(SpatialConstants::PERSISTENCE_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(SpatialConstants::ENTITY_ACL_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(1337, ExternalWorkerPermission);

        // Serialize SomeComponent data
        Worker_ComponentData SomeComponentComponentData{};
        FromUnrealComponentData.component_id = 1337;
        FromUnrealComponentData.schema_type = Schema_CreateComponentData(1337);
        Schema_Object* FromUnrealComponentDataObject = Schema_GetComponentDataFields(FromUnrealComponentData.schema_type);
        Schema_AddInt32(FromUnrealComponentDataObject, 1, 1); // set some_counter to 1 initially

        Components.Add(improbable::Position(improbable::Origin).CreatePositionData());
        Components.Add(improbable::Metadata(TEXT("SessionManager")).CreateMetadataData());
        Components.Add(improbable::Persistence().CreatePersistenceData());
        Components.Add(improbable::EntityAcl(AnyWorkerPermission, ComponentWriteAcl).CreateEntityAclData());
        Components.Add(SessionComponentData);
        Components.Add(FromUnrealComponentData);

        SomeEntity.component_count = Components.Num();
        SomeEntity.components = Components.GetData();

        bool bSuccess = Worker_SnapshotOutputStream_WriteEntity(OutputStream, &SomeEntity) != 0;
        if (bSuccess) 
        {
            NextEntityId++;
        }
        return bSuccess;
    }
}
```

<br/>
------------
2019-03-15 Page added with full editorial review
